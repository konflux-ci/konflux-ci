name: Update Upstream Manifests

env:
  # renovate: datasource=github-releases depName=kubernetes-sigs/kustomize
  KUSTOMIZE_VERSION: "5.4.1"

on:
  # Run on a schedule (daily at 2 AM UTC)
  schedule:
    - cron: '0 2 * * *'
  # Allow manual triggering
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  update-manifests:
    name: Build and Update Upstream Manifests
    runs-on: ubuntu-latest
    defaults:
      run:
        # Default to operator/ directory for most steps, but some steps explicitly
        # change to repo root (for git commands) or pkg/manifests (for scripts)
        working-directory: operator
    steps:
      - name: Checkout repository
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Install Kustomize
        run: |
          KUSTOMIZE_VERSION="${{ env.KUSTOMIZE_VERSION }}"
          ARCH="linux_amd64"

          echo "Installing kustomize v${KUSTOMIZE_VERSION}..."

          # Download and install kustomize
          # Kustomize release tags use format: kustomize/v{VERSION}
          # Download URL format: .../kustomize/v{VERSION}/kustomize_v{VERSION}_{ARCH}.tar.gz
          RELEASE_TAG="kustomize/v${KUSTOMIZE_VERSION}"
          DOWNLOAD_URL="https://github.com/kubernetes-sigs/kustomize/releases/download/${RELEASE_TAG}/kustomize_v${KUSTOMIZE_VERSION}_${ARCH}.tar.gz"

          echo "Downloading from: ${DOWNLOAD_URL}"
          curl -L -f -o kustomize.tar.gz "${DOWNLOAD_URL}"
          tar -xzf kustomize.tar.gz
          chmod +x kustomize
          sudo mv kustomize /usr/local/bin/kustomize

          # Verify installation
          kustomize version
          rm -f kustomize.tar.gz

      - name: Process all components
        id: process
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          cd "${{ github.workspace }}"

          # Configure Git
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"

          # Ensure we're on main branch and up to date
          git checkout main
          git fetch origin main

          # Process all components (script handles loop, processing, and JSON output)
          bash operator/pkg/manifests/process-all-components.sh "${{ github.workspace }}"

      - name: Read component results
        id: results
        if: always()
        run: |
          # Read JSON results file if it exists
          if [ -f /tmp/component-results.json ]; then
            echo "Component results file found"
            cat /tmp/component-results.json
          else
            echo "Component results file not found, workflow may have failed before completion"
            # Create empty JSON structure
            echo '{"failed":[],"successful":[],"up_to_date":[]}' > /tmp/component-results.json
          fi

      - name: Notify on failure
        if: failure()
        uses: actions/github-script@v8
        with:
          script: |
            const fs = require('fs');
            const workflowUrl = `https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`;
            const triggerType = context.eventName === 'schedule' ? 'Scheduled (cron)' : context.eventName;

            // Read component results from JSON file
            let failedComponentsList = '';
            let successfulComponentsList = '';
            let upToDateComponentsList = '';

            try {
              const results = JSON.parse(fs.readFileSync('/tmp/component-results.json', 'utf8'));

              if (results.failed && results.failed.length > 0) {
                failedComponentsList = `\n\n**Failed Components:**\n${results.failed.map(c => `- ${c.component}: ${c.message}`).join('\n')}`;
              }

              if (results.successful && results.successful.length > 0) {
                successfulComponentsList = `\n\n**Successfully Processed Components:**\n${results.successful.map(c => `- ${c.component}: ${c.message}`).join('\n')}`;
              }

              if (results.up_to_date && results.up_to_date.length > 0) {
                upToDateComponentsList = `\n\n**Up-to-date Components:**\n${results.up_to_date.map(c => `- ${c.component}`).join('\n')}`;
              }
            } catch (e) {
              console.log(`Error reading component results: ${e.message}`);
              // Continue with empty lists if file doesn't exist or is invalid
            }

            // Create an issue to notify about the failure
            const title = `⚠️ Upstream Manifests Update Workflow Failed`;
            const body = `The scheduled workflow to update upstream manifests has failed.

            **Workflow Run:** ${workflowUrl}
            **Run ID:** ${context.runId}
            **Trigger:** ${triggerType}${failedComponentsList}${successfulComponentsList}${upToDateComponentsList}

            Please check the workflow logs to identify and fix the issue.

            ---
            *This issue was automatically created by the Update Upstream Manifests workflow*`;

            // Check if an open issue with this title already exists
            const { data: issues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'automated,workflow-failure'
            });

            const existingIssue = issues.find(issue => issue.title === title);

            if (existingIssue) {
              // Add a comment to the existing issue with component information
              const commentBody = `Workflow failed again on ${new Date().toISOString()}\n\n**Workflow Run:** ${workflowUrl}\n**Run ID:** ${context.runId}\n**Trigger:** ${triggerType}${failedComponentsList}${successfulComponentsList}${upToDateComponentsList}\n\nPlease check the workflow logs to identify and fix the issue.`;
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: existingIssue.number,
                body: commentBody
              });
            } else {
              // Create a new issue
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: title,
                body: body,
                labels: ['automated', 'workflow-failure']
              });
            }
