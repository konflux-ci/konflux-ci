name: Operator E2E Tests

on:
  pull_request_target:
    types: [opened, synchronize, reopened, labeled, unlabeled]
  merge_group:
    types: [checks_requested]
  repository_dispatch:
    types: [e2e]

jobs:
  # Gate: bots, repo collaborators (write+), or repository_dispatch/merge_group. Others need /allow from a maintainer.
  check-prerequisites:
    runs-on: ubuntu-latest
    steps:
    - name: Check prerequisites
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        PR_AUTHOR: ${{ github.event.pull_request.user.login }}
      run: |
        # 1. Allow Manual Dispatch or Merge Queue
        if [[ "${{ github.event_name }}" == 'repository_dispatch' || "${{ github.event_name }}" == 'merge_group' ]]; then
          echo "‚úÖ Trigger is ${{ github.event_name }} (Trusted Context). Allowed."
          exit 0
        fi

        # 2. Check Bot Whitelist
        declare -a WHITELISTED_BOTS=(
          "renovate[bot]"
          "red-hat-konflux[bot]"
          "github-actions[bot]"
          "konflux-ci-update-bot[bot]"
        )

        for BOT in "${WHITELISTED_BOTS[@]}"; do
          if [[ "$PR_AUTHOR" == "$BOT" ]]; then
            echo "‚úÖ Author is whitelisted bot ($BOT). Allowed."
            exit 0
          fi
        done

        # 3. Check Repository Permissions (works with private org membership)
        USER_PERM=$(gh api "/repos/${{ github.repository }}/collaborators/$PR_AUTHOR/permission" --jq .permission 2>/dev/null || echo "none")

        if [[ "$USER_PERM" =~ ^(admin|write|maintain)$ ]]; then
          echo "‚úÖ Author ($PR_AUTHOR) has '$USER_PERM' access. Allowed."
          exit 0
        fi

        # 4. Fail and Instruct
        echo "‚ùå Blocked: Untrusted author ($PR_AUTHOR) with permission '$USER_PERM'."

        cat <<EOF >> $GITHUB_STEP_SUMMARY
        ### üõë CI Approval Required
        The PR author is not a maintainer or whitelisted bot.
        **Action Required:** A maintainer must comment \`/allow\` on this PR to trigger tests.
        EOF

        exit 1

  check-changes:
    name: Check for relevant changes
    runs-on: ubuntu-slim
    needs: [check-prerequisites]
    permissions:
      contents: read
      checks: write
    outputs:
      operator: ${{ steps.changed-files.outputs.any_changed }}
      check_run_id: ${{ steps.create-check.outputs.check_run_id }}
      check_run_id_arm64: ${{ steps.create-check.outputs.check_run_id_arm64 }}
    steps:
      - name: Set checkout ref
        id: set-ref
        run: |
          case "${{ github.event_name }}" in
            repository_dispatch) ref=$(jq -r '.client_payload.head_sha' $GITHUB_EVENT_PATH) ;;
            merge_group)        ref=$(jq -r '.merge_group.head_sha' $GITHUB_EVENT_PATH) ;;
            *)                  ref=$(jq -r '.pull_request.head.sha' $GITHUB_EVENT_PATH) ;;
          esac
          echo "ref=$ref" >> $GITHUB_OUTPUT
          echo "Trigger: ${{ github.event_name }} ‚Üí checkout ref: $ref"
      - name: Create check run (comment-triggered)
        if: github.event_name == 'repository_dispatch'
        id: create-check
        uses: actions/github-script@v8
        with:
          script: |
            const head_sha = '${{ steps.set-ref.outputs.ref }}';
            const { data: e2e } = await github.rest.checks.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              name: 'Run Operator E2E Tests',
              head_sha,
              status: 'in_progress'
            });
            const { data: arm64 } = await github.rest.checks.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              name: 'Run Operator Integration Tests (ARM64)',
              head_sha,
              status: 'in_progress'
            });
            core.setOutput('check_run_id', e2e.id);
            core.setOutput('check_run_id_arm64', arm64.id);
      - name: Checkout PR branch
        uses: actions/checkout@v6
        with:
          ref: ${{ steps.set-ref.outputs.ref }}
          fetch-depth: 0
      - name: Check for changes
        uses: tj-actions/changed-files@v47
        id: changed-files
        with:
          files: |
            operator/**
            dependencies/**
            test/e2e/**
            .github/workflows/operator-test-e2e.yaml

  # Lightweight jobs that create status checks when tests are skipped
  # These use the same matrix structure and job names as the test jobs to ensure
  # status checks are always created. Since the 'if' conditions are mutually exclusive,
  # only one of test-skip or test will run, so there's no conflict with duplicate status check names.
  test-skip:
    name: ${{ matrix.job_name }}
    runs-on: ubuntu-slim
    needs: [check-prerequisites, check-changes]
    if: needs.check-changes.outputs.operator != 'true'
    strategy:
      matrix:
        include:
          - arch: amd64
            runner: ubuntu-latest
            kind_binary: kind-linux-amd64
            kubectl_arch: amd64
            image_suffix: ""
            cluster_suffix: ""
            test_scope: "integration+e2e"
            konflux_cr: "operator/config/samples/konflux-e2e.yaml"
            job_name: "Run Operator E2E Tests"
          - arch: arm64
            runner: ubuntu-24.04-arm
            kind_binary: kind-linux-arm64
            kubectl_arch: arm64
            image_suffix: "-arm64"
            cluster_suffix: "-arm"
            test_scope: "integration"
            konflux_cr: "operator/config/samples/konflux_v1alpha1_konflux.yaml"
            job_name: "Run Operator Integration Tests (ARM64)"
    steps:
      - name: Skip test - no operator changes
        run: |
          echo "No operator-related changes detected. Skipping tests."
          echo "This check passes when there are no operator changes to test."

  test:
    name: ${{ matrix.job_name }}
    runs-on: ${{ matrix.runner }}
    needs: [check-prerequisites, check-changes]
    if: needs.check-changes.outputs.operator == 'true'
    strategy:
      matrix:
        include:
          - arch: amd64
            runner: ubuntu-latest
            kind_binary: kind-linux-amd64
            kubectl_arch: amd64
            image_suffix: ""
            cluster_suffix: ""
            test_scope: "integration+e2e"
            konflux_cr: "operator/config/samples/konflux-e2e.yaml"
            job_name: "Run Operator E2E Tests"
          - arch: arm64
            runner: ubuntu-24.04-arm
            kind_binary: kind-linux-arm64
            kubectl_arch: arm64
            image_suffix: "-arm64"
            cluster_suffix: "-arm"
            test_scope: "integration"
            konflux_cr: "operator/config/samples/konflux_v1alpha1_konflux.yaml"
            job_name: "Run Operator Integration Tests (ARM64)"
    env:
      # renovate: datasource=github-releases depName=kubernetes-sigs/kind
      KIND_VERSION: "0.31.0"
      # renovate: datasource=github-releases depName=kubernetes/kubernetes
      KUBECTL_VERSION: "1.35.0"
      OPERATOR_IMAGE: example.com/konflux-operator:v0.0.1${{ matrix.image_suffix }}
      KIND_CLUSTER: konflux-operator-test-e2e${{ matrix.cluster_suffix }}
    defaults:
      run:
        working-directory: operator
    steps:
      - name: Set checkout ref
        id: set-ref
        working-directory: ${{ github.workspace }}
        run: |
          case "${{ github.event_name }}" in
            repository_dispatch) ref=$(jq -r '.client_payload.head_sha' $GITHUB_EVENT_PATH) ;;
            merge_group)        ref=$(jq -r '.merge_group.head_sha' $GITHUB_EVENT_PATH) ;;
            *)                  ref=$(jq -r '.pull_request.head.sha' $GITHUB_EVENT_PATH) ;;
          esac
          echo "ref=$ref" >> $GITHUB_OUTPUT
          echo "Trigger: ${{ github.event_name }} ‚Üí checkout ref: $ref"
      - name: Free Disk Space (Ubuntu)
        uses: jlumbroso/free-disk-space@main
        with:
          tool-cache: false
          docker-images: false

      - name: Clone the code
        uses: actions/checkout@v6
        with:
          ref: ${{ steps.set-ref.outputs.ref }}

      - name: Disable AppArmor
        # works around a change in ubuntu 24.04 that restricts Linux namespace access
        # for unprivileged users
        run: sudo sysctl -w kernel.apparmor_restrict_unprivileged_userns=0

      - name: Setup Go
        uses: actions/setup-go@v6
        with:
          go-version-file: operator/go.mod
          cache-dependency-path: operator/go.sum

      - name: Install kind (${{ matrix.arch }})
        run: |
          curl -Lo ./kind https://kind.sigs.k8s.io/dl/v${KIND_VERSION}/${{ matrix.kind_binary }}
          chmod +x ./kind
          sudo mv ./kind /usr/local/bin/kind

      - name: Install kubectl (${{ matrix.arch }})
        run: |
          curl -LO "https://dl.k8s.io/release/v${KUBECTL_VERSION}/bin/linux/${{ matrix.kubectl_arch }}/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/kubectl

      - name: Verify kind installation
        run: kind version

      - name: Deploy Konflux using deploy-local.sh
        working-directory: ${{ github.workspace }}
        env:
          # Cluster configuration
          KIND_CLUSTER: ${{ env.KIND_CLUSTER }}
          OPERATOR_INSTALL_METHOD: "build"
          OPERATOR_IMAGE: ${{ env.OPERATOR_IMAGE }}

          KONFLUX_CR: ${{ matrix.konflux_cr }}

          # GitHub App secrets (standardized names)
          GITHUB_PRIVATE_KEY: ${{ secrets.APP_PRIVATE_KEY }}
          GITHUB_APP_ID: ${{ secrets.APP_ID }}
          WEBHOOK_SECRET: ${{ secrets.APP_WEBHOOK_SECRET }}

          # Quay secrets for E2E tests (standardized names)
          QUAY_TOKEN: ${{ matrix.test_scope == 'integration+e2e' && secrets.QUAY_TOKEN || '' }}
          QUAY_ORGANIZATION: ${{ matrix.test_scope == 'integration+e2e' && secrets.QUAY_ORG || '' }}

          # Smee webhook forwarding for E2E tests only
          SMEE_CHANNEL: ${{ matrix.test_scope == 'integration+e2e' && secrets.SMEE_CHANNEL || '' }}
        run: ./scripts/deploy-local.sh

      - name: Show version information
        working-directory: operator
        run: |
          kubectl version
          kind version

      - name: Wait for Konflux CR to be Ready
        run: |
          # Wait for the Konflux CR to be ready
          # If the operator deployment is ready and the CR is ready, the operator should have
          # ensured all underlying services (webhooks, CRDs, etc.) are ready
          echo "Waiting for Konflux CR to be ready..."
          kubectl wait --for=condition=Ready=True konflux konflux --timeout=15m
          echo "Konflux CR is ready!"

      - name: List namespaces
        run: |
          kubectl get namespace

      - name: Deploy Test Resources
        working-directory: ${{ github.workspace }}
        env:
          SKIP_SAMPLE_COMPONENTS: "true"
        run: |
          ./deploy-test-resources.sh

      - name: Run Konflux Integration Tests
        working-directory: ${{ github.workspace }}
        run: |
          cd test/go-tests
          go test ./...

      - name: Run E2E tests
        if: matrix.test_scope == 'integration+e2e'
        working-directory: ${{ github.workspace }}
        env:
          GH_ORG: ${{ secrets.GH_ORG }}
          GH_TOKEN: ${{ secrets.GH_TOKEN }}
          QUAY_DOCKERCONFIGJSON: ${{ secrets.QUAY_DOCKERCONFIGJSON }}
          RELEASE_CATALOG_TA_QUAY_TOKEN: ${{ secrets.RELEASE_CATALOG_TA_QUAY_TOKEN }}
        run: |
          ./test/e2e/run-e2e.sh

      - name: Generate error logs
        if: ${{ !cancelled() }}
        working-directory: ${{ github.workspace }}
        run: |
          echo "Konflux CR:"
          kubectl get konflux konflux -o yaml || :
          ./generate-err-logs.sh

      - name: Archive logs
        if: ${{ !cancelled() }}
        uses: actions/upload-artifact@v6
        with:
          name: logs-${{ matrix.arch }}
          path: logs

  # Report check result to PR when triggered by /allow (so the run appears on the PR and can gate it)
  report-operator-e2e-status:
    if: always() && needs.check-changes.outputs.check_run_id != ''
    needs: [check-changes, test-skip, test]
    runs-on: ubuntu-latest
    permissions:
      checks: write
    steps:
      - name: Update check runs
        uses: actions/github-script@v8
        with:
          script: |
            const checkRunId = parseInt(process.env.CHECK_RUN_ID);
            const checkRunIdArm64 = parseInt(process.env.CHECK_RUN_ID_ARM64);
            const testResult = process.env.TEST_RESULT;
            const testSkipResult = process.env.TEST_SKIP_RESULT;
            let conclusion = 'failure';
            if (testResult === 'success' || testSkipResult === 'success') conclusion = 'success';
            else if (testResult === 'cancelled' || testSkipResult === 'cancelled') conclusion = 'cancelled';
            const update = { owner: context.repo.owner, repo: context.repo.repo, status: 'completed', conclusion };
            await github.rest.checks.update({ ...update, check_run_id: checkRunId });
            await github.rest.checks.update({ ...update, check_run_id: checkRunIdArm64 });
        env:
          CHECK_RUN_ID: ${{ needs.check-changes.outputs.check_run_id }}
          CHECK_RUN_ID_ARM64: ${{ needs.check-changes.outputs.check_run_id_arm64 }}
          TEST_RESULT: ${{ needs.test.result }}
          TEST_SKIP_RESULT: ${{ needs.test-skip.result }}
