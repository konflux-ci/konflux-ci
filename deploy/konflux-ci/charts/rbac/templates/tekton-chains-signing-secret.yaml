apiVersion: batch/v1
kind: Job
metadata:
  name: tekton-chains-signing-secret
  namespace: {{ .Values.TektonPipelinesNamespace }}
  labels:
  {{- include "rbac.labels" . | nindent 4 }}
  annotations:
    argocd.argoproj.io/hook-delete-policy: BeforeHookCreation
    argocd.argoproj.io/sync-options: SkipDryRunOnMissingResource=true
    argocd.argoproj.io/sync-wave: "1"
spec:
  template:
    metadata:
      annotations:
        argocd.argoproj.io/sync-options: SkipDryRunOnMissingResource=true
    spec:
      containers:
      - command:
        - /bin/bash
        - -c
        - |
          set -o errexit
          set -o nounset
          set -o pipefail

          namespace="tekton-pipelines"
          secret="signing-secrets"

          cd /tmp

          if [ "$(kubectl get secret "$secret" -n "$namespace" -o jsonpath='{.data}' --ignore-not-found --allow-missing-template-keys)" != "" ]; then
            echo "Signing secret exists and is non-empty."
          else
            # Delete secret/signing-secrets if already exists since by default cosign creates immutable secrets
            kubectl delete secrets "$secret" -n "$namespace" --ignore-not-found=true

            # To make this run conveniently without user input let's create a random password
            RANDOM_PASS=$( openssl rand -base64 30 )

            # Generate the key pair secret directly in the cluster.
            # The secret should be created as immutable.
            echo "Generating k8s secret/$secret in $namespace with key-pair"
            env COSIGN_PASSWORD=$RANDOM_PASS cosign generate-key-pair "k8s://$namespace/$secret"
          fi

          echo "Generating/updating the secret with the public key"
          kubectl create secret generic public-key \
            --namespace "$namespace" \
            --from-literal=cosign.pub="$(
              cosign public-key --key "k8s://$namespace/$secret"
            )" \
            --dry-run=client \
            -o yaml | kubectl apply -f -

          # Temporarily creating the secret also on openshift-pipelines namespace
          kubectl create secret generic public-key \
            --namespace openshift-pipelines \
            --from-literal=cosign.pub="$(
              cosign public-key --key "k8s://$namespace/$secret"
            )" \
            --dry-run=client \
            -o yaml | kubectl apply -f -
        env:
        - name: KUBERNETES_CLUSTER_DOMAIN
          value: {{ quote .Values.kubernetesClusterDomain }}
        image: {{ .Values.tektonChainsSigningSecret.chainsSecretGeneration.image.repository
          }}:{{ .Values.tektonChainsSigningSecret.chainsSecretGeneration.image.tag
          | default .Chart.AppVersion }}
        imagePullPolicy: {{ .Values.tektonChainsSigningSecret.chainsSecretGeneration.imagePullPolicy
          }}
        name: chains-secret-generation
        resources: {{- toYaml .Values.tektonChainsSigningSecret.chainsSecretGeneration.resources
          | nindent 10 }}
        securityContext: {{- toYaml .Values.tektonChainsSigningSecret.chainsSecretGeneration.containerSecurityContext
          | nindent 10 }}
      dnsPolicy: ClusterFirst
      restartPolicy: OnFailure
      serviceAccount: chains-secrets-admin
      serviceAccountName: chains-secrets-admin
      terminationGracePeriodSeconds: 30
